import chai = require('chai');
const expect = chai.expect;
import sinon = require('sinon');
import proxyquire = require('proxyquire');

import os = require('os');
import path = require('path');
import oidentd = require('../../shadowd/oidentd');

describe('OidentdFile suite', function() {
  let OidentdFile: any;
  let sinonSandbox;
  let writeFileSpy;

  const fileVal = '~/.oidentd.conf';
  const expectedFile = path.join(os.homedir(), '.oidentd.conf');
  const socketF: oidentd.ISocket = {
    remoteAddress: '192.168.1.2',
    remotePort: 1337,
    localAddress: '127.0.0.1',
    localPort: 1338
  };
  const connectionF: oidentd.IConnection = {
    user: 'foo',
    socket: socketF
  };

  beforeEach(function () {
    OidentdFile = proxyquire('../../shadowd/oidentd', {
      'fs': { writeFile: Function.prototype }
    }).OidentdFile;
    sinonSandbox = sinon.sandbox.create();
  });

  afterEach(function() {
    sinonSandbox.restore();
  });

  describe('ctor', function() {
    it('should contruct itself with oident file when specified', function() {
      const oidentd = new OidentdFile(fileVal);
      expect(oidentd._file).to.equal(expectedFile);
    });

    it('should call refresh from the ctor', function() {
      const refreshSpy = sinon.spy();
      sinonSandbox.stub(OidentdFile.prototype, 'refresh', refreshSpy);
      new OidentdFile(fileVal);
      expect(refreshSpy.calledOnce).to.be.true;
    });

    it('should construct with a null value from the default config', function() {
      const config = require('../../../defaults/config');
      const construct = () => new OidentdFile(config.oidentd);
      expect(construct).to.not.throw(TypeError);
    });
  });

  it('should add connection when added', function() {
    const ofile = new OidentdFile(null);
    ofile.addConnection(connectionF);
    expect(Object.keys(ofile._connections).length).to.equal(1);
    const connection = ofile._connections['0'];
    const socket = connection.socket;
    expect(socket).to.not.be.undefined;
    expect(connection.user).to.equal(connectionF.user);
    expect(connection.user).to.equal(connectionF.user);
    expect(Object.keys(socket).length).to.equal(4);
    Object.keys(socket).forEach((prop) => expect(socket[prop]).to.equal(socketF[prop]));
  });

  it('should remove connection when removed by id', function() {
    const ofile = new OidentdFile(null);
    ofile.addConnection(connectionF);
    expect(Object.keys(ofile._connections).length).to.equal(1);
    ofile.removeConnection(0);
    expect(Object.keys(ofile._connections).length).to.equal(0);
  });

  it('makeRule should return a valid rule given a connection', function() {
    const expectedRule = 'to 192.168.1.2 lport 1338 from 127.0.0.1 fport 1337 { reply "foo" }\n';
    const oidentd = new OidentdFile(fileVal);
    const rule = oidentd.makeRule(connectionF);
    expect(rule).to.equal(expectedRule);
  });

  it('should write correct file when refreshed', function() {
    const expectedContents =
      '# Warning: file generated by The Lounge: changes will be overwritten!\n' +
      'to 192.168.1.2 lport 1338 from 127.0.0.1 fport 1337 { reply "foo" }\n';
    let enableWriteFileExpectations = false;

    const writeFileMock = (filename: string, contents: string, opt: any, errcb: any) => {
      if(enableWriteFileExpectations) {
        expect(filename).to.equal(expectedFile);
        expect(contents).to.equal(expectedContents);
        expect(opt.flag).to.equal('w+');
        expect(() => errcb(new Error())).to.throw('Failed to update oidentd file!');
        expect(() => errcb()).to.not.throw('Failed to update oidentd file!');
      }
    }

    OidentdFile = proxyquire('../../shadowd/oidentd', {
      'fs': { writeFile: writeFileMock }
    }).OidentdFile;

    const oidentd = new OidentdFile(fileVal);
    enableWriteFileExpectations = true;
    oidentd.addConnection(connectionF);
    oidentd.refresh();
  });
});

